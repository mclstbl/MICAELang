<!DOCTYPE html>

<html>
<head>
  <title>MICAELang: Multiplatform Illustrated Context-Free ASCII Emoji Language</title>
  <meta http-equiv="content-type" content="text/html; charset=UTF-8">
  <link rel="stylesheet" media="all" href="public/stylesheets/normalize.css" />
  <link rel="stylesheet" media="all" href="plain.css" />
</head>
<body>
  <div class="container">
    <div class="page">

      <div class="header">
        
          
          <h1 id="micaelang-multiplatform-illustrated-context-free-ascii-emoji-language">MICAELang: Multiplatform Illustrated Context-Free ASCII Emoji Language</h1>
<h2 id="by-micaela-e-estabillo">By Micaela E. Estabillo</h2>
<h2 id="april-2016">April 2016</h2>

          
        

        
      </div>

      
        
        <h3 id="introduction">Introduction</h3>
<p>MICAELang is an esoteric context-free language which is compiled using JavaScript (to target language JavaScript) in the browser. The source language is comprised of emojis, numbers, 
strings and mathematical/boolean operators. The compiler runs solely in the browser and was written in “vanilla” JavaScript, which means that no servers, external APIs 
or frameworks were used. Due to the maximum
stack call limits in client-side browser applications, the compilation steps had to be separated into smaller stages, which will be explained in this report.</p>

        
      
        
        <h3 id="problem">Problem</h3>
<p>The creation of MICAELang was inspired by two current situations.
First, there are a total of 845 emojis supported across all smartphone and computer platforms (Emojipedia), and each one has an associated meaning. These graphical characters
are often used in messaging in order to communicate. Secondly, mainstream compilers require installation on a local computer; most online compilers such as Ideone connect to a 
remote server on which the input code is compiled then return the results to the browser. The purpose of MICAELang is to create a language which can be parsed and executed purely within
a browser.</p>

        
      
        
        <h3 id="history-and-background">History and Background</h3>
<p>The MICAELang project’s purpose is to use esoteric programming concepts and perform a minimal amount of computation in the background so that compilation can run in the browser.
A similar idea is implemented in Skulpt (Graham), which is an in-browser implementation of Python. The main selling point of Skulpt is the fact that it is compiled in the client
side and so there is no risk of throttling a remote server, and that there is no installation required to use it. </p>

        
      
        
        <p>The main differences between MICAELang and Skulpt are:</p>
<ul>
<li>The grammar is not as large as Python’s. MICAELang currently only supports Mathematical and Boolean expression assignments, and print statements.</li>
<li>MICAELang is context-free - the syntax of expressions are a bit different from Python because there is no support for parentheses.</li>
</ul>

        
      
        
        <h3 id="analysis-and-design">Analysis and Design</h3>
<p>MICAELang is an application written in JavaScript, which is a programming language commonly used to control the behaviour of web browsers. It follows that the application
runs on a web platform since most browsers are capable of running JavaScript; no installation is required on the user’s end.</p>

        
      
        
        <p>Initially, the project was designed to use meteor.js in order to use a preexisting parser generator called Jison. However, since the MICAELang grammar is very simple and writing
a parser was not very complicated, external frameworks proved to be of no use. Instead, a tool called Browserify is utilized in the app’s build process in order to 
bundle up all the smaller modules into one script which is loaded onto the HTML web interface. The most obvious effect of Browserify is the enablement of 
the <code>require</code>, <code>module</code>, and <code>exports</code> keywords which typically do not run on the client side of a web application. </p>

        
      
        
        <p>Overall, each MICAELang compilation has 4 stages: user I/O, tokenization, parsing and code generation. Each step is contained in a separate module, and modifies the system’s state.
In a typical execution,the user enters MICAELang code into an HTML interface, which is forwarded to the tokenization module to prepare the code for parsing. 
It is important to mention that all identifiers found in the source code are recorded in a symbol table, which is used during code generation. 
Finally, after the code is generated, the resulting action (or error) is displayed back to the browser.</p>

        
      
        
        <p>The documentation, including this report, was generated using literate programming with the open-source tool Docco and some shell scripting. 
Generating this report required some maneuvering using a shell build script in order to make it look pretty - Browserify adds extra lines to the generated script which does
not display well using only Docco.</p>

        
      
        
        <h3 id="documentation">Documentation</h3>
<p>The following function header starts off the Browserify-generated script bundle. It enables the <code>exports</code>, <code>require</code> and <code>module</code> JavaScript keywords.  </p>

        
          <div class='highlight'><pre>(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">e</span>(<span class="hljs-params">t,n,r</span>)</span>{<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">s</span>(<span class="hljs-params">o,u</span>)</span>{<span class="hljs-keyword">if</span>(!n[o]){<span class="hljs-keyword">if</span>(!t[o]){<span class="hljs-keyword">var</span> a=<span class="hljs-keyword">typeof</span> <span class="hljs-built_in">require</span>==<span class="hljs-string">"function"</span>&amp;&amp;<span class="hljs-built_in">require</span>;<span class="hljs-keyword">if</span>(!u&amp;&amp;a)<span class="hljs-keyword">return</span> a(o,!<span class="hljs-number">0</span>);<span class="hljs-keyword">if</span>(i)<span class="hljs-keyword">return</span> i(o,!<span class="hljs-number">0</span>);<span class="hljs-keyword">var</span> f=<span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">"Cannot find module '"</span>+o+<span class="hljs-string">"'"</span>);<span class="hljs-keyword">throw</span> f.code=<span class="hljs-string">"MODULE_NOT_FOUND"</span>,f}<span class="hljs-keyword">var</span> l=n[o]={exports:{}};t[o][<span class="hljs-number">0</span>].call(l.exports,<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">e</span>)</span>{<span class="hljs-keyword">var</span> n=t[o][<span class="hljs-number">1</span>][e];<span class="hljs-keyword">return</span> s(n?n:e)},l,l.exports,e,t,n,r)}<span class="hljs-keyword">return</span> n[o].exports}<span class="hljs-keyword">var</span> i=<span class="hljs-keyword">typeof</span> <span class="hljs-built_in">require</span>==<span class="hljs-string">"function"</span>&amp;&amp;<span class="hljs-built_in">require</span>;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> o=<span class="hljs-number">0</span>;o&lt;r.length;o++)s(r[o]);<span class="hljs-keyword">return</span> s})({<span class="hljs-number">1</span>:[<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">require,module,exports</span>)</span>{</pre></div>
        
      
        
        <h4 id="stage-1-user-i-o">STAGE 1: USER I/O</h4>
<p>There are three components in the web Graphical User Interface (GUI): the editable textarea, clickable “Compile” button, and the read-only output textarea.
Together, they emulate an Integrated Development Environment (IDE) where users can edit, run and view their programs.</p>

        
      
        
        <p>The button triggers the compilation when it is clicked so whenever the main HTML page loads, an EventListener is created in order to detect mouseclicks.
Also, <code>textarea</code> elements have read/write access by default so I turn on read-only mode for the output box whenever the page is loaded.</p>

        
          <div class='highlight'><pre><span class="hljs-built_in">window</span>.onload = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) 
</span>{
  btn = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">'submitArea'</span>);
  btn.addEventListener(<span class="hljs-string">'click'</span>, compile, <span class="hljs-literal">false</span>);

  <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">"outputArea"</span>).readOnly = <span class="hljs-literal">true</span>;
}</pre></div>
        
      
        
        <p>This function processes the target code generated using the MICAELang input, and is called after compilation is finished. 
The results of a compilation are posted on the right hand side of the browser (in the read-only textarea) as user output.</p>

        
          <div class='highlight'><pre><span class="hljs-keyword">var</span> PROGNAME = <span class="hljs-string">""</span>;

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">stdout</span>(<span class="hljs-params">RESULT</span>)
</span>{
  str = RESULT;
  date = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>();
  time = date.toLocaleTimeString().concat(<span class="hljs-string">" $ "</span>); 
  <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">'outputArea'</span>).innerHTML += <span class="hljs-string">" "</span> + PROGNAME + <span class="hljs-string">"\n"</span> + <span class="hljs-string">"\n"</span> + time;
  <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">'outputArea'</span>).scrollTop = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">'outputArea'</span>).scrollHeight;
}</pre></div>
        
      
        
        <p>The compilation sequence begins here. The parser, symbol and codegen modules are required from here. While not explicitly imported, the tokenize module
is crucial to compilation but is called from the parse module.</p>

        
          <div class='highlight'><pre><span class="hljs-keyword">var</span> PARSER = <span class="hljs-built_in">require</span>(<span class="hljs-string">'./3_parser'</span>);
<span class="hljs-keyword">var</span> SYM = <span class="hljs-built_in">require</span>(<span class="hljs-string">'./4_symbol'</span>);
<span class="hljs-keyword">var</span> CODEGEN = <span class="hljs-built_in">require</span>(<span class="hljs-string">'./5_codegen'</span>);

exports.compile = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) 
</span>{
  obj = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">"input"</span>);
  <span class="hljs-keyword">var</span> CODE = obj.value.toString().trim();
  <span class="hljs-keyword">if</span> (CODE == <span class="hljs-string">''</span>) { <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"no"</span>); <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;}</pre></div>
        
      
        
        <p>The <code>ALL</code> variable contains information about this system’s state after each stage of compilation. It is a record containing the tokens, string inputs, symbol table
and error pertaining to the source code. It is passed from module to module so that the state is available at any time. If an error is thrown at any stage, the compilation
is aborted and an error is presented to the user.</p>

        
          <div class='highlight'><pre>  ALL = PARSER.parse(CODE);</pre></div>
        
      
        
        <p>DELETE</p>

        
          <div class='highlight'><pre>  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> key <span class="hljs-keyword">in</span> ALL.ST)
  {
    str = <span class="hljs-string">"id: "</span> + ALL.ST[key].identifier + <span class="hljs-string">" type: "</span> + ALL.ST[key].type + <span class="hljs-string">" value: "</span> + ALL.ST[key].value;
    <span class="hljs-built_in">console</span>.log(str);
  }

  TMP = {<span class="hljs-string">"T"</span>:ALL.ST,<span class="hljs-string">"E"</span>:ALL.E};
  l = SYM.lookup(<span class="hljs-string">'PROGNAME'</span>,TMP);
  PROGNAME = l == <span class="hljs-literal">undefined</span> ? <span class="hljs-string">""</span> : l;</pre></div>
        
      
        
        <p>DELETE </p>

        
          <div class='highlight'><pre>

  <span class="hljs-keyword">if</span> (ALL.E != <span class="hljs-string">""</span>)
  {
    stdout(ALL.E);
  }</pre></div>
        
      
        
        <p>The code generator only returns 2 entities in a record: a JavaScript code to be evaluated using built-in JS function <code>eval</code> and the error string.</p>

        
          <div class='highlight'><pre>  <span class="hljs-keyword">else</span>
  {
    OUTPUT = CODEGEN.generate(ALL);
    str = OUTPUT.E == <span class="hljs-string">""</span> ? OUTPUT.JS : OUTPUT.E;
    stdout(<span class="hljs-built_in">eval</span>(str));
  }
}</pre></div>
        
      
        
        <p>As mentioned in the <em>Analysis</em>, Browserify adds some lines to the output code before each module so here is another one.</p>

        
          <div class='highlight'><pre>
},{<span class="hljs-string">"./3_parser"</span>:<span class="hljs-number">4</span>,<span class="hljs-string">"./4_symbol"</span>:<span class="hljs-number">5</span>,<span class="hljs-string">"./5_codegen"</span>:<span class="hljs-number">6</span>}],<span class="hljs-number">2</span>:[<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">require,module,exports</span>)</span>{</pre></div>
        
      
        
        <h4 id="the-micaelang-grammar">The MICAELang Grammar</h4>
<p>Before moving on to the other modules, here is the MICAELang grammar explained. Not all of the productions defined here are compiled correctly as of now, but they are all
syntactically parse-able.</p>

        
      
        
        <p><code>LEX</code> is a hash table that defines the tokens and regular expression patterns for the grammar’s keywords.
There are only 3 data types accepted and they are inferred by the parser: Number, String and Boolean. Everything else that is not an operand or keyword is interpreted
as an identifier.</p>

        
          <div class='highlight'><pre><span class="hljs-keyword">var</span> LEX = [];
LEX[<span class="hljs-string">'START'</span>] = 			<span class="hljs-regexp">/\:D/</span>;
LEX[<span class="hljs-string">'EOF'</span>] = 				<span class="hljs-regexp">/\:\(/</span>;
LEX[<span class="hljs-string">'PROGRAM'</span>] = 		<span class="hljs-regexp">/^[A-Z]+([A-Za-z]*\d*)*/</span>;
LEX[<span class="hljs-string">'ELSEIF'</span>] = 		<span class="hljs-regexp">/\:\?\?/</span>;
LEX[<span class="hljs-string">'IF'</span>] = 				<span class="hljs-regexp">/\:\?/</span>;
LEX[<span class="hljs-string">'ELSE'</span>] = 			<span class="hljs-regexp">/\?/</span>;
LEX[<span class="hljs-string">'LBRACKET'</span>] = 	<span class="hljs-regexp">/\\_/</span>;
LEX[<span class="hljs-string">'RBRACKET'</span>] =		<span class="hljs-regexp">/_\//</span>;
LEX[<span class="hljs-string">'PRINT'</span>] = 			<span class="hljs-regexp">/!{3}/</span>;
LEX[<span class="hljs-string">'AND'</span>] = 				<span class="hljs-regexp">/&lt;3/</span>;
LEX[<span class="hljs-string">'OR'</span>] = 				<span class="hljs-regexp">/\:\*/</span>;
LEX[<span class="hljs-string">'FI'</span>] = 				<span class="hljs-regexp">/\*/</span>;
LEX[<span class="hljs-string">'EQ'</span>] = 				<span class="hljs-regexp">/={2}/</span>;
LEX[<span class="hljs-string">'IS'</span>] = 				<span class="hljs-regexp">/={1}/</span>;
LEX[<span class="hljs-string">'PLUS'</span>] = 			<span class="hljs-regexp">/\+/</span>;
LEX[<span class="hljs-string">'MINUS'</span>] = 			<span class="hljs-regexp">/-/</span>;
LEX[<span class="hljs-string">'MULT'</span>] = 			<span class="hljs-regexp">/\*/</span>;
LEX[<span class="hljs-string">'DIV'</span>] = 				<span class="hljs-regexp">/\//</span>;
LEX[<span class="hljs-string">'POW'</span>] = 				<span class="hljs-regexp">/\^/</span>;
LEX[<span class="hljs-string">'LT'</span>] = 				<span class="hljs-regexp">/&lt;/</span>;
LEX[<span class="hljs-string">'GT'</span>] = 				<span class="hljs-regexp">/&gt;/</span>;
LEX[<span class="hljs-string">'NUMBER'</span>] = 		<span class="hljs-regexp">/^\d*$/</span>;
LEX[<span class="hljs-string">'STRING'</span>] = 		<span class="hljs-regexp">/^".*"$/</span>;
LEX[<span class="hljs-string">'BOOLEAN'</span>] = 		<span class="hljs-regexp">/true|false/</span>;
LEX[<span class="hljs-string">'COMMENT'</span>] = 		<span class="hljs-regexp">/\#/</span>;
LEX[<span class="hljs-string">'EOL'</span>] = 				<span class="hljs-regexp">/\~/</span>;
LEX[<span class="hljs-string">'IDENTIFIER'</span>] =	<span class="hljs-regexp">/^[a-z]*([0-9]*[A-Za-z]*)*/</span>;
LEX[<span class="hljs-string">'UNDEFINED'</span>] = 	<span class="hljs-regexp">/.*/</span>;

exports.getLEX = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)
</span>{
  <span class="hljs-keyword">return</span> LEX;
}</pre></div>
        
      
        
        <p>The <code>RULES</code> hash table contains key-value pairs containing the token and a list of acceptable right-hand side tokens.
The grammar is left-recursive which means that the operators or functions are on the left-hand side and the operands are on the right. The parser supports
unlimited operands, but they have to be of the same type.</p>

        
          <div class='highlight'><pre><span class="hljs-keyword">var</span> RULES = [];
RULES[<span class="hljs-string">'NUMBER'</span>]=    [<span class="hljs-string">'NUMBER'</span>,<span class="hljs-string">'EOL'</span>];
RULES[<span class="hljs-string">'BOOLEAN'</span>]=   [<span class="hljs-string">'BOOLEAN'</span>,<span class="hljs-string">'EOL'</span>];
RULES[<span class="hljs-string">'STRING'</span>]=    [<span class="hljs-string">'STRING'</span>,<span class="hljs-string">'EOL'</span>];
RULES[<span class="hljs-string">'IDENTIFIER'</span>]=[<span class="hljs-string">'IS'</span>,<span class="hljs-string">'NUMBER'</span>,<span class="hljs-string">'STRING'</span>,<span class="hljs-string">'BOOLEAN'</span>,<span class="hljs-string">'EOL'</span>];
RULES[<span class="hljs-string">'PROGRAM'</span>]=   [<span class="hljs-string">'EOL'</span>];
RULES[<span class="hljs-string">'PLUS'</span>]=      [<span class="hljs-string">'NUMBER'</span>,<span class="hljs-string">'IDENTIFIER'</span>];
RULES[<span class="hljs-string">'MINUS'</span>]=     [<span class="hljs-string">'NUMBER'</span>,<span class="hljs-string">'IDENTIFIER'</span>];
RULES[<span class="hljs-string">'MULT'</span>]=      [<span class="hljs-string">'NUMBER'</span>,<span class="hljs-string">'IDENTIFIER'</span>];
RULES[<span class="hljs-string">'DIV'</span>]=       [<span class="hljs-string">'NUMBER'</span>,<span class="hljs-string">'IDENTIFIER'</span>];
RULES[<span class="hljs-string">'POW'</span>]=       [<span class="hljs-string">'NUMBER'</span>,<span class="hljs-string">'IDENTIFIER'</span>];
RULES[<span class="hljs-string">'LT'</span>]=        [<span class="hljs-string">'NUMBER'</span>,<span class="hljs-string">'IDENTIFIER'</span>];
RULES[<span class="hljs-string">'GT'</span>]=        [<span class="hljs-string">'NUMBER'</span>,<span class="hljs-string">'IDENTIFIER'</span>];
RULES[<span class="hljs-string">'IS'</span>]=        [<span class="hljs-string">'NUMBER'</span>,<span class="hljs-string">'STRING'</span>,<span class="hljs-string">'BOOLEAN'</span>,<span class="hljs-string">'IDENTIFIER'</span>,<span class="hljs-string">'POW'</span>,<span class="hljs-string">'MULT'</span>,<span class="hljs-string">'DIV'</span>,<span class="hljs-string">'PLUS'</span>,<span class="hljs-string">'MINUS'</span>,<span class="hljs-string">'LT'</span>,<span class="hljs-string">'GT'</span>,<span class="hljs-string">'AND'</span>,<span class="hljs-string">'OR'</span>,<span class="hljs-string">'EQ'</span>];
RULES[<span class="hljs-string">'EQ'</span>]=        [<span class="hljs-string">'NUMBER'</span>,<span class="hljs-string">'STRING'</span>,<span class="hljs-string">'BOOLEAN'</span>,<span class="hljs-string">'IDENTIFIER'</span>];
RULES[<span class="hljs-string">'AND'</span>]=       [<span class="hljs-string">'BOOL'</span>,<span class="hljs-string">'IDENTIFIER'</span>];
RULES[<span class="hljs-string">'OR'</span>]=        [<span class="hljs-string">'BOOL'</span>,<span class="hljs-string">'IDENTIFIER'</span>]; 
RULES[<span class="hljs-string">'PRINT'</span>]=     [<span class="hljs-string">'STRING'</span>,<span class="hljs-string">'NUMBER'</span>,<span class="hljs-string">'IDENTIFIER'</span>];
RULES[<span class="hljs-string">'EOL'</span>]=       [<span class="hljs-string">'ELSEIF'</span>,<span class="hljs-string">'IF'</span>,<span class="hljs-string">'ELSE'</span>,<span class="hljs-string">'FI'</span>,<span class="hljs-string">'IDENTIFIER'</span>,<span class="hljs-string">'PRINT'</span>,<span class="hljs-string">'COMMENT'</span>,<span class="hljs-string">'EOF'</span>];
RULES[<span class="hljs-string">'START'</span>]=     [<span class="hljs-string">'PROGRAM'</span>];
RULES[<span class="hljs-string">'EOF'</span>]=       [];</pre></div>
        
      
        
        <p>There are three syntax subdivisions which are also accessable as part of the rules: math operators, bool operators and expressions.</p>

        
          <div class='highlight'><pre>RULES[<span class="hljs-string">'OPERATORS'</span>] =    [<span class="hljs-string">'POW'</span>,<span class="hljs-string">'MULT'</span>,<span class="hljs-string">'DIV'</span>,<span class="hljs-string">'PLUS'</span>,<span class="hljs-string">'MINUS'</span>];
RULES[<span class="hljs-string">'BOOL_OPS'</span>] =     [<span class="hljs-string">'LT'</span>,<span class="hljs-string">'GT'</span>,<span class="hljs-string">'AND'</span>,<span class="hljs-string">'OR'</span>,<span class="hljs-string">'EQ'</span>];
RULES[<span class="hljs-string">'EXPRESSIONS'</span>] =  [<span class="hljs-string">'NUMBER'</span>,<span class="hljs-string">'STRING'</span>,<span class="hljs-string">'BOOLEAN'</span>,<span class="hljs-string">'IDENTIFIER'</span>];</pre></div>
        
      
        
        <p>The following rules for comments, parentheses, and conditionals are not implemented in the parsing yet. 
Although their syntax can be verified when used as input, the semantics are not interpretable by the parser as of now.</p>

        
          <div class='highlight'><pre>RULES[<span class="hljs-string">'COMMENT'</span>]=   [<span class="hljs-string">'ELSEIF'</span>,<span class="hljs-string">'IF'</span>,<span class="hljs-string">'ELSE'</span>,<span class="hljs-string">'FI'</span>,<span class="hljs-string">'STRING'</span>,<span class="hljs-string">'COMMENT'</span>,<span class="hljs-string">'EOL'</span>];
RULES[<span class="hljs-string">'LBRACKET'</span>]=  [<span class="hljs-string">'NUMBER'</span>,<span class="hljs-string">'STRING'</span>,<span class="hljs-string">'BOOLEAN'</span>,<span class="hljs-string">'IDENTIFIER'</span>,<span class="hljs-string">'COMMENT'</span>];
RULES[<span class="hljs-string">'RBRACKET'</span>]=  [<span class="hljs-string">'NUMBER'</span>,<span class="hljs-string">'STRING'</span>,<span class="hljs-string">'BOOLEAN'</span>,<span class="hljs-string">'IDENTIFIER'</span>,<span class="hljs-string">'COMMENT'</span>,<span class="hljs-string">'EOL'</span>];
RULES[<span class="hljs-string">'IF'</span>]=        [<span class="hljs-string">'BOOLEAN'</span>,<span class="hljs-string">'IDENTIFIER'</span>,<span class="hljs-string">'LT'</span>,<span class="hljs-string">'GT'</span>,<span class="hljs-string">'EQ'</span>,<span class="hljs-string">'AND'</span>,<span class="hljs-string">'OR'</span>,<span class="hljs-string">'LBRACKET'</span>];
RULES[<span class="hljs-string">'ELSEIF'</span>]=    [<span class="hljs-string">'BOOLEAN'</span>,<span class="hljs-string">'IDENTIFIER'</span>,<span class="hljs-string">'LT'</span>,<span class="hljs-string">'GT'</span>,<span class="hljs-string">'EQ'</span>,<span class="hljs-string">'AND'</span>,<span class="hljs-string">'OR'</span>,<span class="hljs-string">'LBRACKET'</span>];
RULES[<span class="hljs-string">'ELSE'</span>]=      [<span class="hljs-string">'POW'</span>,<span class="hljs-string">'MULT'</span>,<span class="hljs-string">'DIV'</span>,<span class="hljs-string">'PLUS'</span>,<span class="hljs-string">'MINUS'</span>,<span class="hljs-string">'IF'</span>,<span class="hljs-string">'PRINT'</span>,<span class="hljs-string">'COMMENT'</span>,<span class="hljs-string">'FI'</span>];
RULES[<span class="hljs-string">'FI'</span>]=        [<span class="hljs-string">'EOL'</span>,<span class="hljs-string">'COMMENT'</span>];

exports.getRULES = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">return</span> RULES;
}


},{}],<span class="hljs-number">3</span>:[<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">require,module,exports</span>)</span>{</pre></div>
        
      
        
        <h4 id="stage-2-tokenization">STAGE 2: TOKENIZATION</h4>
<p>Tokenization serves as an intermediate step of compilation in order to make parsing simpler. In this process, the raw input code is split into an array. The array contents
are assigned tokens according to the grammar rules and this will make it easier for the parser to check patterns later.</p>

        
          <div class='highlight'><pre>
<span class="hljs-keyword">var</span> GRAMMAR = <span class="hljs-built_in">require</span>(<span class="hljs-string">'./1_grammar'</span>);
<span class="hljs-keyword">var</span> SYM = <span class="hljs-built_in">require</span>(<span class="hljs-string">'./4_symbol'</span>);</pre></div>
        
      
        
        <p>The <code>tokenize</code> function takes an array of strings as input and returns the state of the system.
This function scans every word in the <code>CODE</code> string and determines the appropriate token to represent it. The meaning behind the program is not meant to be
interpreted at this point. Instead, individual words (strings) are checked to see if they are a member of the grammar.</p>

        
      
        
        <p>Since this is the first compilation stage after I/O, the symbol table, tokenized code and error are initialized here.</p>

        
          <div class='highlight'><pre>exports.tokenize = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">CODE</span>)
</span>{
  <span class="hljs-keyword">var</span> TOKENS = GRAMMAR.getLEX();
  <span class="hljs-keyword">var</span> TOKENIZED_CODE = [];
  <span class="hljs-keyword">var</span> SYMBOL_TABLE = {<span class="hljs-string">"T"</span> : [], <span class="hljs-string">"E"</span> : <span class="hljs-string">""</span>};
  <span class="hljs-keyword">var</span> error = <span class="hljs-string">""</span>;</pre></div>
        
      
        
        <p>When <code>tokenize</code> is invoked, CODE contains a string so it needs to be split by whitespace to form <code>WORDS</code>, which is an array.</p>

        
          <div class='highlight'><pre>  CODE = CODE.replace(<span class="hljs-regexp">/(\r\n|\n|\r|\t)/gm</span>,<span class="hljs-string">" "</span>);
  <span class="hljs-keyword">var</span> WORDS = CODE.split(<span class="hljs-regexp">/ +/</span>);</pre></div>
        
      
        
        <p>The regular expressions which are in the hash table <code>TOKENS</code> are tested against each element of <code>WORD</code> to determine which token fits best.</p>

        
          <div class='highlight'><pre>  <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; WORDS.length; i ++) 
  {
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> key <span class="hljs-keyword">in</span> TOKENS)
    {
      <span class="hljs-keyword">var</span> re = <span class="hljs-keyword">new</span> <span class="hljs-built_in">RegExp</span>(TOKENS[key]);
      <span class="hljs-keyword">if</span> (re.exec(WORDS[i]) != <span class="hljs-literal">null</span>)
      {</pre></div>
        
      
        
        <p>JavaScript crashes if the word is not found in the hash table at all so the token <code>UNDEFINED</code> is assigned to those which do not fit anywhere else and an error is thrown.</p>

        
          <div class='highlight'><pre>        <span class="hljs-keyword">if</span> (key == <span class="hljs-string">'UNDEFINED'</span>)
        {
          error = <span class="hljs-string">"ERROR: '"</span> + WORDS[i] + <span class="hljs-string">"' is unrecognized "</span>;
          <span class="hljs-keyword">return</span> {<span class="hljs-string">"TOKENIZED"</span> : TOKENIZED_CODE, <span class="hljs-string">"SYMBOLS"</span> : SYMBOL_TABLE, <span class="hljs-string">"ERROR"</span> : error};
        }</pre></div>
        
      
        
        <p>If the word is an identifier or is the keyword <code>START</code>, it needs to be recorded in the symbol table.</p>

        
          <div class='highlight'><pre>        <span class="hljs-keyword">if</span> (key == <span class="hljs-string">'IDENTIFIER'</span> || key == <span class="hljs-string">'PROGRAM'</span>)
        {
           sym = (key == <span class="hljs-string">'PROGRAM'</span>) ? <span class="hljs-keyword">new</span> SYM.SYMBOL(<span class="hljs-string">'PROGRAM'</span>,<span class="hljs-string">'PROGNAME'</span>,WORDS[i]) : <span class="hljs-keyword">new</span> SYM.SYMBOL(<span class="hljs-literal">undefined</span>,WORDS[i],<span class="hljs-literal">undefined</span>);
           SYMBOL_TABLE = SYM.insert(sym,SYMBOL_TABLE);
           error = SYMBOL_TABLE.E;
        }
        TOKENIZED_CODE[i] = key;
        <span class="hljs-keyword">break</span>;
      }
    }
  }</pre></div>
        
      
        
        <p>After scanning the code for tokens, the <code>TOKENIZED_CODE</code>, <code>WORDS</code> and <code>SYMBOL_TABLE</code> arrays, and the <code>ERROR</code> string are returned to the
parse function for further processing.</p>

        
          <div class='highlight'><pre>  <span class="hljs-keyword">return</span> {<span class="hljs-string">"T"</span> : TOKENIZED_CODE, <span class="hljs-string">"W"</span> : WORDS, <span class="hljs-string">"ST"</span> : SYMBOL_TABLE.T, <span class="hljs-string">"E"</span> : error};
}
},{<span class="hljs-string">"./1_grammar"</span>:<span class="hljs-number">2</span>,<span class="hljs-string">"./4_symbol"</span>:<span class="hljs-number">5</span>}],<span class="hljs-number">4</span>:[<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">require,module,exports</span>)</span>{</pre></div>
        
      
        
        <h4 id="stage-3-parsing">STAGE 3: PARSING</h4>
<p>After tokenizing, the parser performs a few checks in order to verify that the source code is syntactically correct and is ready for code generation.
Since the grammar is left-recursive, the more commonly used recursive descent parsing method is not used here. Moreover, due to JavaScript stack call limits,
the initially planned one-pass parsing is not implemented here. Instead, there are 3 main functions executed within the main <code>parse</code> sequence</p>
<ul>
<li><code>checkSyntax</code></li>
<li><code>simplifyExpressions</code></li>
<li><code>simplifyBools</code></li>
</ul>

        
          <div class='highlight'><pre>
<span class="hljs-keyword">var</span> TOKENIZER = <span class="hljs-built_in">require</span>(<span class="hljs-string">'./2_tokenizer'</span>);
<span class="hljs-keyword">var</span> GRAMMAR = <span class="hljs-built_in">require</span>(<span class="hljs-string">'./1_grammar'</span>);
<span class="hljs-keyword">var</span> SYM = <span class="hljs-built_in">require</span>(<span class="hljs-string">'./4_symbol'</span>);

exports.parse = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">CODE</span>) 
</span>{ 
  ALL = TOKENIZER.tokenize(CODE);</pre></div>
        
      
        
        <p>If an error is detected at any parsing stage, compilation is aborted. The <code>ALL.E</code> value contains the error string and is empty if there are no errors.</p>

        
      
        
        <p>The <code>checkSyntax</code> checks if the source code tokens satisfy MICAELang’s grammar rules.
Aside from the error string, the <code>checkSyntax</code> call also checks if the MICAELang starting header is included. Otherwise, an error is returned.</p>

        
          <div class='highlight'><pre>  ALL = ALL.T[<span class="hljs-number">0</span>] == <span class="hljs-string">'START'</span> &amp;&amp; ALL.T.length &gt;= <span class="hljs-number">2</span> &amp;&amp; ALL.E == <span class="hljs-string">""</span> ? checkSyntax(<span class="hljs-number">1</span>,ALL) 
      : {<span class="hljs-string">"T"</span> : ALL.T, <span class="hljs-string">"W"</span> : ALL.W, <span class="hljs-string">"ST"</span> : ALL.ST, <span class="hljs-string">"E"</span> : <span class="hljs-string">"ERROR: Program entry point not found"</span>};</pre></div>
        
      
        
        <p>Mathematical expressions are simplified here as much as possible and their values are stored in the symbol table.
Similar to the previous check, <code>simplifyExpressions</code> only runs if there is no error. Otherwise, it does nothing, which causes the error to propagate 
to the main compilation sequence and abort the process.</p>

        
          <div class='highlight'><pre>  ALL = ALL.E == <span class="hljs-string">""</span> ? simplifyExpressions(ALL) : ALL;</pre></div>
        
      
        
        <p>The tokens, source code, symbol table and error are returned back to the compiler module. But really, the most important effect of this module is arguably
the populated symbol table.</p>

        
          <div class='highlight'><pre>  <span class="hljs-keyword">return</span> ALL;
}</pre></div>
        
      
        
        <p>The <code>checkSyntax</code> function recursively checks the next token to see if the production <code>&lt;CURRENT,NEXT&gt;</code> are accepted by the grammar.
It returns the state of the system upon completion. <code>ALL.E</code> would contain an error string if an illegal token is found.</p>

        
          <div class='highlight'><pre><span class="hljs-keyword">var</span> checkSyntax = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">n,ALL</span>)
</span>{
  <span class="hljs-keyword">if</span> (n == ALL.T.length || ALL.E != <span class="hljs-string">""</span>)
  {
    <span class="hljs-keyword">return</span> ALL;
  }
  <span class="hljs-keyword">else</span>
  {
    <span class="hljs-keyword">var</span> G = GRAMMAR.getRULES();
    <span class="hljs-keyword">var</span> NEXT = ALL.T[n];
    <span class="hljs-keyword">var</span> CUR = ALL.T[n - <span class="hljs-number">1</span>];

    <span class="hljs-keyword">if</span>(G[CUR].indexOf(NEXT) != <span class="hljs-number">-1</span>)
    {
      <span class="hljs-keyword">return</span> checkSyntax(n + <span class="hljs-number">1</span>,ALL);
    }
    <span class="hljs-keyword">else</span>
    {
      ALL.E = <span class="hljs-string">"ERROR: '"</span> + NEXT + <span class="hljs-string">"' is not accepted by the grammar"</span>;
    }
  }
  <span class="hljs-keyword">return</span> ALL;
}</pre></div>
        
      
        
        <p>Mention typeCheck and apply
Populates and maintains the symbol table</p>

        
          <div class='highlight'><pre><span class="hljs-keyword">var</span> simplifyExpressions = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">ALL</span>)
</span>{
  G = GRAMMAR.getRULES();
  o = <span class="hljs-number">0</span>; n = <span class="hljs-number">0</span>;
  cur = ALL.T[n];

  <span class="hljs-keyword">while</span>(cur != <span class="hljs-string">'EOF'</span> &amp;&amp; ALL.E == <span class="hljs-string">""</span>)
  {
    OPERANDS = [];
    <span class="hljs-keyword">if</span>(G[<span class="hljs-string">'OPERATORS'</span>].indexOf(cur) != <span class="hljs-number">-1</span> &amp;&amp; ALL.T[n - <span class="hljs-number">2</span>] == <span class="hljs-string">'IDENTIFIER'</span> &amp;&amp; ALL.T[n - <span class="hljs-number">1</span>] == <span class="hljs-string">'IS'</span>)
    {
      ID = ALL.W[n<span class="hljs-number">-2</span>];
      OP = ALL.W[n];
      o = n + <span class="hljs-number">1</span>;
      <span class="hljs-keyword">while</span> (cur != <span class="hljs-string">'EOL'</span>)
      {
        n ++;
        cur = ALL.T[n];
      }
      OPERANDS = ALL.W.slice(o,n);
      <span class="hljs-keyword">if</span> (!typeCheck(ALL.T.slice(o,n)))
      {
        ALL.E = <span class="hljs-string">"ERROR: Incompatible types"</span>
        <span class="hljs-keyword">break</span>;
      }
      type = ALL.T[<span class="hljs-number">6</span>];
      sym = <span class="hljs-keyword">new</span> SYM.SYMBOL(type,ID,apply(OP,OPERANDS));
      TMP = SYM.insert(sym,ALL.ST);
      ALL.ST = TMP.T;
      ALL.E = TMP.E;
      <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"done"</span>);
    }
    n ++;
    cur = ALL.T[n]; 
  }
  <span class="hljs-keyword">return</span> ALL;
}

<span class="hljs-keyword">var</span> apply = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">OP,OPERANDS</span>)
</span>{
  n = <span class="hljs-number">0</span>;
  str = <span class="hljs-string">""</span>;
  ctr = <span class="hljs-number">0</span>;
  l = OPERANDS.length;
  <span class="hljs-keyword">while</span> (n &lt; l)
  {
    str = str.concat(OP,OPERANDS[n]);
  }
  
  <span class="hljs-keyword">return</span> <span class="hljs-built_in">eval</span>(str);
}</pre></div>
        
      
        
        <p>This function returns true if two expressions are of compatible types and false if they are not.</p>

        
          <div class='highlight'><pre><span class="hljs-keyword">var</span> typeCheck = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">OPERANDS</span>)
</span>{
  l = OPERANDS.length;
  <span class="hljs-keyword">if</span> (l &gt; <span class="hljs-number">0</span>)
  {
    o = OPERANDS[<span class="hljs-number">0</span>];
    <span class="hljs-keyword">for</span>(i = <span class="hljs-number">0</span>; i &lt; l; i ++)
    {
      <span class="hljs-keyword">if</span>(OPERANDS[i] != o)
      {
        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>
      }
    }
  }
  <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
}</pre></div>
        
      
        
        
        
          <div class='highlight'><pre>},{<span class="hljs-string">"./1_grammar"</span>:<span class="hljs-number">2</span>,<span class="hljs-string">"./2_tokenizer"</span>:<span class="hljs-number">3</span>,<span class="hljs-string">"./4_symbol"</span>:<span class="hljs-number">5</span>}],<span class="hljs-number">5</span>:[<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">require,module,exports</span>)</span>{</pre></div>
        
      
        
        <h4 id="the-symbol-table">The Symbol Table</h4>
<p>The <code>symbol.js</code> module defines a structure for containing the identifier, type, and value of variables (<code>IDENTIFIER</code>) in MICAELang. The actual table
is a hash of key-value pairs of identifiers and their associated <code>SYMBOL</code> objects.</p>

        
      
        
        <p>This module defines three methods</p>
<ul>
<li><code>lookup</code></li>
<li><code>update</code></li>
<li><code>insert</code></li>
</ul>

        
      
        
        <p>During the tokenization and parsing of a program, this module maintains a symbols table containing 0 or more instances of <code>SYMBOL</code>. The three methods
are designed such that duplicate symbols are not allowed in the language, and type mismatches cause a compilation error.</p>

        
      
        
        <p>The SYMBOL object has three fields: type, identifier and value.</p>

        
          <div class='highlight'><pre><span class="hljs-keyword">var</span> SYMBOL = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">t,i,v</span>)
</span>{
  <span class="hljs-keyword">this</span>.type = t;
  <span class="hljs-keyword">this</span>.identifier = i;
  <span class="hljs-keyword">this</span>.value = v;
}

SYMBOL.prototype = {
  doX : <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{}
}

exports.SYMBOL = SYMBOL;</pre></div>
        
      
        
        <p>The <code>lookup</code> function returns the current value of the identifier in the symbol table if it exists, and returns <code>undefined</code> otherwise.</p>

        
          <div class='highlight'><pre><span class="hljs-keyword">var</span> lookup = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">ID,ALL</span>)
</span>{
  <span class="hljs-keyword">if</span> (ALL.T = [])
  {
    <span class="hljs-keyword">return</span> <span class="hljs-literal">undefined</span>;
  }
  <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (ALL.T[ID] != <span class="hljs-literal">undefined</span>)
  {
    <span class="hljs-keyword">return</span> ALL.T[ID].value;    
  }
  <span class="hljs-keyword">return</span> <span class="hljs-literal">undefined</span>;
}

exports.lookup = lookup;</pre></div>
        
      
        
        <p>The <code>update</code> function attempts to modify the value of an existing symbol table entry.
It returns the new status of the symbol table, and the <code>ERROR</code> string, which is empty unless there is a type mismatch.</p>

        
          <div class='highlight'><pre><span class="hljs-keyword">var</span> update = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">SYM,ALL</span>)
</span>{
  <span class="hljs-keyword">if</span> (ALL.T[SYM.identifier].type == SYM.type)
  {
    ALL.T[SYM.identifier].value = SYM.value;
    <span class="hljs-built_in">console</span>.log (<span class="hljs-string">"Updated sym table"</span>);
  }
  <span class="hljs-keyword">else</span>
  {
    ALL.E = <span class="hljs-string">"ERROR: Type mismatch in inserting '"</span> + SYM.identifier + <span class="hljs-string">"' into symbol table"</span>
  }
  <span class="hljs-keyword">return</span> ALL;
}

exports.update = update;</pre></div>
        
      
        
        <p>The <code>insert</code> function adds a new entry to the symbol table if it does not exist yet; otherwise, it tries to update the symbol associated with the identifier.
It returns an array containing the new status of the symbol table and the <code>ERROR</code> string. Note that if the identifier exists in the symbol table, the error
depends on the return value of the <code>update</code> function.</p>

        
          <div class='highlight'><pre><span class="hljs-keyword">var</span> insert = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">SYM,ALL</span>)
</span>{
  <span class="hljs-keyword">if</span> (lookup(SYM.identifier,ALL.T) == <span class="hljs-literal">undefined</span>)
  {
    ALL.T[SYM.identifier] = SYM;
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"Inserted into symbol table"</span>);
  }
  <span class="hljs-keyword">else</span>
  {
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"New sym table entry"</span>);
    ALL = update(SYM,TABLE);
  }
  <span class="hljs-keyword">return</span> ALL;
}

exports.insert = insert;</pre></div>
        
      
        
        <p>The following function returns the type of an identifier if it exists in the table, and returns undefined if lookup fails to find the entry.</p>

        
          <div class='highlight'><pre>exports.getType = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">ID,ALL</span>)
</span>{
  <span class="hljs-keyword">if</span> (lookup(ID,ALL) != <span class="hljs-literal">undefined</span>)
  {
    <span class="hljs-keyword">return</span> ALL.T[ID].type;    
  }
  <span class="hljs-keyword">return</span> <span class="hljs-literal">undefined</span>;
}</pre></div>
        
      
        
        <h3 id="code-generation">Code Generation</h3>

        
          <div class='highlight'><pre>},{}],<span class="hljs-number">6</span>:[<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">require,module,exports</span>)</span>{</pre></div>
        
      
        
        <h4 id="stage-4-code-generation">STAGE 4: CODE GENERATION</h4>

        
          <div class='highlight'><pre>
<span class="hljs-keyword">var</span> SYM = <span class="hljs-built_in">require</span>(<span class="hljs-string">'./4_symbol'</span>);
<span class="hljs-keyword">var</span> TOKENIZER = <span class="hljs-built_in">require</span>(<span class="hljs-string">'./2_tokenizer'</span>);

exports.generate = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">ALL</span>) 
</span>{</pre></div>
        
      
        
        <p>The productions that are allowed in the language is be defined by EXPRESSIONS.</p>

        
      
        
        <p>return {“TOKENIZED” : TOKENIZED_CODE, “SYMBOLS” : SYMBOL_TABLE, “ERROR” : error};</p>

        
          <div class='highlight'><pre>
  WORDS = ALL.W;

  JS = <span class="hljs-string">"\"hello\""</span>;
  <span class="hljs-keyword">return</span> {<span class="hljs-string">"JS"</span>:JS, <span class="hljs-string">"E"</span>:<span class="hljs-string">""</span>};
}</pre></div>
        
      
        
        
        
          <div class='highlight'><pre>},{<span class="hljs-string">"./2_tokenizer"</span>:<span class="hljs-number">3</span>,<span class="hljs-string">"./4_symbol"</span>:<span class="hljs-number">5</span>}]},{},[<span class="hljs-number">1</span>]);</pre></div>
        
      
        
        <h3 id="testing">Testing</h3>
<p>Test plan – how the program/system was verified. Put the actual test results in the Appendix. This section is useful if your project is more on the software engineering side than research focused.  </p>

        
      
        
        <p>The MICAELang project was tested using whitebox unit tests. Each module builds on top of other ones so each one was verified incrementally before moving on to write the next
module. Since there are no testing frameworks currently available for this language (MICAELang), testing was done manually by writing snippets of code and compiling
to see the output.</p>

        
      
        
        <p>The first unit to be tested was the tokenizer.
Symbol module
Parser
Codegen</p>

        
      
        
        <p>The testing details on each of the units are available in the Appendix section of this paper.</p>

        
      
        
        <h3 id="results">Results</h3>
<p>This covers different areas to the ‘Testing’ chapter, and is appropriate for ‘research style’ projects. For such projects this chapter should detail the types of experiments/simulations that were carried out with the code written. Why were certain experiments carried out but not others? What were the important parameters in the simulation and how did they affect the results? If there are very many graphs and tables associated with this chapter they may be put in the Appendix, but it is generally better to keep these close to the text they illustrate, as this is easier for the reader.</p>

        
      
        
        <h3 id="conclusion-evaluation-and-further-work">Conclusion, Evaluation and Further Work</h3>
<p>What have you achieved? Give a critical appraisal (evaluation) of your own work - how could the work be taken further (perhaps by another student next year)?</p>

        
      
        
        <p>This file will contain report sections after Implementation</p>

        
      
        
        <h3 id="appendix">APPENDIX</h3>
<h4 id="-testing-tokenizer-"><em>Testing: Tokenizer</em></h4>
<p>   <pre><code>
   = + - <em> / &lt; ^ &gt; == :</em> &lt;3 1314213  “hello” “hi” true     ashka</p>
<h1 id="-hello-"># hello #</h1>
<p>   [          ] :D :( ~ 121kjn
   </code></pre>
tabs,newlines,spaces to see if they would be ignored
deliberate syntax error to see if it would be detected
manually verify that each one’s corresponding token is correct</p>

        
      
        
        <h4 id="-testing-symbol-table-"><em>Testing: Symbol table</em></h4>
<h4 id="-testing-parser-"><em>Testing: Parser</em></h4>
<p>Minimal working MICAELang parse</p>
<pre><code>
:D Hello ~
:(
</code></pre>

        
      
        
        <h4 id="-testing-code-generator-"><em>Testing: Code generator</em></h4>

        
      
        
        <h3 id="references">References</h3>
<p>// This is a hack - copy bibtex format</p>

        
      
        
        <p>This is [an example][id] reference-style link.</p>

        
      
        
        <p>This is <a href="http://example.com/" title="Title">an example</a> inline link.</p>

        
      
        
        <p>Sphere Research Labs. “What is Ideone”. <a href="https://ideone.com/">https://ideone.com/</a>. March 3, 2016.
Emojipedia Pty Ltd. “FAQ”. <a href="http://emojipedia.org/faq/">http://emojipedia.org/faq/</a>. March 3, 2016.
Graham, Scott. Skulpt. <a href="http://www.skulpt.org/">http://www.skulpt.org/</a></p>

        
      
      <div class="fleur">h</div>
    </div>
  </div>
</body>
</html>
